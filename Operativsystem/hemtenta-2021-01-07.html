<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html lang="sv">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Operativsystem för civilingenjörer: Hemtentamen 2021-01-07</title>
<STYLE TYPE="text/css">
     P.breakhere {page-break-before: always}
</STYLE>
</head>

<body bgcolor="#ffffff" text="#000000" link="#0000cc" vlink="#551a8b" alink="#ff0000">


<h1><a href="../../index.html">Operativsystem för civilingenjörer</a>: Hemtentamen 2021-01-07</h1>

Det här är hemtentan som går torsdag 7 januari 2021 i kursen
DT513G Operativsystem för civilingenjörer
vid Örebro universitet, provkod A001.
Ansvarig lärare är
<a href="http://www.aass.oru.se/~tpy/">Thomas Padron-McCarthy</a>
(<a href="mailto:thomas.padron-mccarthy@oru.se?subject=Operativsystem-hemtenta 2021-01-07">thomas.padron-mccarthy@oru.se</a>),
telefon <b>070-73 47 013</b>.

<p>

Tid: 09:15 - 14:15



<h2>Instruktioner</h2>

<ol>

<li>
Den här hemtentan ersätter den planerade salstentan.

<li>
Uppgifterna ska lösas enskilt, dvs inga grupper av två eller flera studenter.

<li>
<b>Du får använda dator, böcker och vilka andra hjälpmedel som helst,</b>
men du får inte samarbeta eller fråga någon (utom mig).
Exempelvis är det tillåtet att söka och läsa på webbplatser som Stack Overflow, men inte att ställa egna frågor.
Du kan alltså provköra kommandon och program, om du vill.

<li>
<b>Diskutera inte uppgifterna eller dela med dig av svar förrän tidigast dagen efter tentan.</b>

<li>
Lös de angivna uppgifterna och samla svaren på lämpligt sätt,
till exempel i en PDF.
Skicka sen in lösningarna till mig i
<a href="http://lms.oru.se/">Blackboard</a>.
Välj <b>Kursmaterial</b> i menyn till vänster på kursens Blackboard-sida,
gå in i mappen <b>Hemtentamen</b>,
och välj den rätta tentan.
Där kan man sedan välja att skicka in sin lösning.
Då blir bedömningen anonym.
Glöm inte att klicka på knappen <b>Skicka</b> längst ner till höger.

<li>
Om det skulle bli problem med Blackboard,
kan man i nödfall skicka in svaren
antingen som ett kursmeddelande i Blackboard
eller via vanlig e-post
(<a href="mailto:thomas.padron-mccarthy@oru.se?subject=Databasteknik-hemtenta 2020-06-03">thomas.padron-mccarthy@oru.se</a>),
senast vid tentatidens slut.
Då blir bedömningen inte anonym.

<li>
I Blackboard ser du att du skickat in din lösning.
Om du i stället skickade in med e-post,
och inte senast en timme efter tentatidens slut fått
ett svar från mig med en bekräftelse
på att du skickat in svaren,
bör du kontakta mig, enklast genom att ringa eller SMS:a mig
(ifall det är e-posten som inte fungerar).
Tänk på att en del mailtjänster
(särskilt Microsoft-tjänster som Hotmail.com, Outlook.com och Live.com)
ibland kastar bort brev med bilagor, utan att meddela det.

<li>
Skriv gärna svaren i ett ordbehandlingsprogram.
Rita gärna eventuella diagram i ett ritprogram.
Det är inte förbjudet att skriva och rita för hand,
men då måste text och bilder scannas in eller fotograferas.
Det finns scanner-appar till Android och iPhone,
till exempel Adobe Scan,
som ger bättre resultat än att bara ta vanliga kort med kameran.

<li>
Tentatiden är utökad med en extra timme
för att täcka in problem med e-post, inscanning eller fotografering av diagram, och liknande.

<li>
Om du behöver fråga något, så kontakta gärna mig.
Ring eller skicka SMS,
för jag kanske inte kommer att sitta vid datorn hela tiden.

<li>
Oklara och tvetydiga formuleringar kommer att misstolkas.
Lösningar som inte går att läsa eller förstå kan naturligtvis inte ge några poäng. 

<li>
Antaganden utöver de som står i uppgifterna måste anges. Gjorda antaganden får inte förändra den givna uppgiften.

<li>
Skriv gärna förklaringar om hur du tänkt. Även ett svar som är fel kan ge poäng, om det finns med en förklaring som visar att huvudtankarna var rätt. 

<li>
Maximal poäng är 28.
För godkänt betyg krävs minst 15 poäng.

<li>
Resultat meddelas senast 15 arbetsdagar efter tentamensdatum.
Eftersom svaren skickas in elektroniskt scannas tentorna inte för retur.

</ol>



<P CLASS="breakhere">



<a name="uppgift-1"></a>
<h2>Uppgift 1 (5 p)</h2>

Man brukar säga att operativsystemet erbjuder en virtuell maskin.
Samtidigt finns det virtualisering, som också handlar om virtuella maskiner.
Vad är skillnaden? Är det helt olika saker, eller hänger de ihop på något sätt?
Jämför och förklara!



<a name="uppgift-2"></a>
<h2>Uppgift 2 (3 p)</h2>

Man brukar säga att en viktig skillnad mellan trådar och processer
i många vanliga operativsystem är
att varje process har sin egen minnesrymd, medan flera trådar kan dela på samma minnesrymd.
Men en annan skillnad är att operativsystemkärnan alltid måste känna till alla processer,
men det kan hända att det finns trådar som operativsystemkärnan inte vet om.
Förklara hur det kan vara möjligt!



<a name="uppgift-3"></a>
<h2>Uppgift 3 (6 p)</h2>

a) Vad menas <b>spinlock</b> och <b>busy-wait</b> (även kallat <b>spinning</b>)?

<p>

b) Ge exempel på när det kan vara lämpligt för operativsystemkärnan att använda dessa.

<p>

c) Under vilka omständigheter bör operativsystemkärnan absolut <i>inte</i> använda dessa?

<p>

d) Varför är det normalt inte lämpligt att använda dem i vanliga program?



<a name="uppgift-4"></a>
<h2>Uppgift 4 (5 p)</h2>

Den dyraste processor som just nu (6 januari) finns i lager enligt prisjämförelsesajten
<a href="https://www.prisjakt.nu/">prisjakt.nu</a>
är
<b>AMD Epyc 7H12</b>.
Den har 64 kärnor, AMD:s motsvarighet till hyperthreading så den kan köra 128 parallella trådar,
och en klockfrekvens på 2,6 GHz.
Den kostar 85646 kronor.

<p>

Den billigaste processorn är
<b>AMD Mobile Sempron 3200+</b>.
Den har en kärna, ingen hyperthreading, och en klockfrekvens på 1,6 GHz.
Den kostar 48 kronor.

<p>

När man ska ange hur snabb en dator är använder man ibland enheten <b>flops</b>,
floating-point operations per second, som anger hur många flyttalsoperationer
datorn kan utföra på en sekund.
Här nedan finns ett program,
<a href="flops.c">flops.c</a>,
som utför en massa flyttalsdivisioner, i en eller flera trådar,
och sen skriver ut hur många flops det blev.
Man anger antalet trådar med ett kommandoradsargument när man startar programmet.

<p>

<table border="1" cellspacing="0" cellpadding="3" width="90%"><tr><td bgcolor="#ccffcc">
<pre>
// Several threads, each performing many floating-point divisions
// Compile with:
// gcc -Wall -Wextra -std=c11 -O3 flops.c -lpthread -o flops
// Note 1: gcc with -O3 did not remove the actual calculations,
// but an aggressively optimizing compiler could.
// Note 2: Normal "int" is too small for some of the values,
// so we use "long long int".
// Thomas Padron-McCarthy (thomas.padron-mccarthy@oru.se)
// Wed Jan  6 19:23:21 CET 2021

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;float.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/time.h&gt;

#define NR_DIVISIONS_PER_THREAD (1LL*1000*1000*1000)
#define STARTING_VALUE 1e50
#define FACTOR 1.0000001

int nr_finished_threads = 0;

void *thread_body(void *arg) {
    int thread_number = (int)arg;
    double value = STARTING_VALUE;
    printf("Thread %d starting with value %g, factor %.10f...\n",
           thread_number, value, FACTOR);
    for (long long int i = 0; i &lt; NR_DIVISIONS_PER_THREAD; ++i) {
        value /= FACTOR;
    }
    printf("Thread %d finishing with value %g.\n", thread_number, value);
    ++nr_finished_threads;
    return NULL;
} // thread_body

int main(int argc, char *argv[]) {
    int nr_threads;
    if (argc != 2 || sscanf(argv[1], "%d", &amp;nr_threads) != 1 || nr_threads &lt; 1) {
        fprintf(stderr, "Usage: flops NUMBER-OF-THREADS\n");
        exit(EXIT_FAILURE);
    }
    
    printf("This program starts %d thread(s).\n", nr_threads);
    printf("Each thread performs %lld floating-point divisions\n",
           NR_DIVISIONS_PER_THREAD);

    pthread_t threads[nr_threads];
    printf("Starting the %d thread(s)...\n", nr_threads);

    struct timeval before;
    gettimeofday(&amp;before, NULL);

    for (int i = 0; i &lt; nr_threads; ++i) {
        if (pthread_create(&amp;threads[i], NULL, thread_body, (void*)(i + 1)) != 0) {
            fprintf(stderr, "Couldn't create thread %d.\n", i);
            exit(EXIT_FAILURE);
        }
    }

    printf("%d threads started. Waiting for them to finish...\n", nr_threads);

    for (int i = 0; i &lt; nr_threads; ++i) {
        if (pthread_join(threads[i], NULL) != 0) {
            fprintf(stderr, "Couldn't join thread for thread %d.\n", i);
            exit(EXIT_FAILURE);
        }
    }

    struct timeval after;
    gettimeofday(&amp;after, NULL);
    double elapsed_seconds =
        after.tv_sec - before.tv_sec + (after.tv_usec - before.tv_usec) / 1e6;

    printf("All threads finished (%d threads)!\n", nr_finished_threads);
    printf("Elapsed time: %.6f s\n", elapsed_seconds);
    long long int total_divisions = nr_threads * NR_DIVISIONS_PER_THREAD;
    printf("We have performed %lld floating-point divisions.\n", total_divisions);
    double flops = total_divisions / elapsed_seconds;
    printf("Flops (floating-point operations per second): %.0f = %.0f Mflops\n",
           flops, flops / (1000 * 1000));
    
    return EXIT_SUCCESS;
} // main
</pre>
</td></tr></table>

<p>

Vi provkör programmet ovan, med en tråd, på den dyra processorn.
Det tar 2,0 sekunder, och ger 500 Mflops ("mega-flops", dvs miljoner flops).
Vi provkör också programmet, med en tråd, på den billiga processorn.
Det tar 4,0 sekunder, och ger 250 Mflops.

<p>

Hur lång tid kan vi räkna med att det tar,
och hur många Mflops kan vi räkna med att vi får,
om vi kör programmet:

<p>

a) med två trådar på den dyra processorn?
<br>
b) med två trådar på den billiga processorn?
<br>
c) med tio trådar på den dyra processorn?
<br>
d) med tio trådar på den billiga processorn?
<br>
e) med hundra trådar på den dyra processorn?
<br>
f) med hundra trådar på den billiga processorn?
<br>
g) med tusen trådar på den dyra processorn?
<br>
h) med tusen trådar på den billiga processorn?



<a name="uppgift-5"></a>
<h2>Uppgift 5 (3 p)</h2>

När programmet i uppgiften ovan kört klart alla trådarna skriver det ut att de är klara,
och hur många det var. Exempel:

<p>

<table border="1" cellspacing="0" cellpadding="3"><tr><td>
<pre>
All threads finished (2 threads)!
</pre>
</td></tr></table>

<p>

I en av våra provkörningar med 1000 trådar blir utskriften fel:

<p>

<table border="1" cellspacing="0" cellpadding="3"><tr><td>
<pre>
All threads finished (998 threads)!
</pre>
</td></tr></table>

<p>

Förklara varför det blev fel,
och visa hur man kan ändra programmet så man slipper felet.



<a name="uppgift-6"></a>
<h2>Uppgift 6 (3 p)</h2>

På labbarna i kursen har vi sett andra flertrådade program,
bland annat i labb 2 där vi såg
<b>thread-performance-test-2020</b>
och (när ni gjort om det till en flertrådad version)
<b>single-threaded-monster-world</b>.
När man varierar antalet trådar i programmet <b>flops</b>
varierar prestandan på ett liknande sätt som ett av dessa.

<p>

a) Vilket?

<p>

b) Förklara vad det är för likheter och skillnader mellan programmen som gör att det blir så!



<P CLASS="breakhere">



<a name="uppgift-7"></a>
<h2>Uppgift 7 (3 p)</h2>

Ju mindre minnessidor ("pages") man har, desto större blir page-tabellen.
Förklara varför!

<p>

<hr>

<font size=-1>
<a href="http://www.aass.oru.se/~tpy/">Thomas Padron-McCarthy</a>
(<a href="mailto:thomas.padron-mccarthy@oru.se?subject=Operativsystem-hemtenta 2021-01-07">thomas.padron-mccarthy@oru.se</a>),
6 januari 2021
</font>

</body>
</html>
