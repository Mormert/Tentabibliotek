<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html lang="sv">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Operativsystem för civilingenjörer: Hemtentamen 2021-06-01</title>
<STYLE TYPE="text/css">
     P.breakhere {page-break-before: always}
</STYLE>
</head>

<body bgcolor="#ffffff" text="#000000" link="#0000cc" vlink="#551a8b" alink="#ff0000">


<h1><a href="../../index.html">Operativsystem för civilingenjörer</a>: Hemtentamen 2021-06-01</h1>

Det här är hemtentan som går tisdag 1 juni 2021 i kursen
DT513G Operativsystem för civilingenjörer
vid Örebro universitet, provkod A001.
Ansvarig lärare är
<a href="http://www.aass.oru.se/~tpy/">Thomas Padron-McCarthy</a>
(<a href="mailto:thomas.padron-mccarthy@oru.se?subject=Operativsystem-hemtenta 2021-06-01">thomas.padron-mccarthy@oru.se</a>),
telefon <b>070-73 47 013</b>.

<p>

Tid: 08:15 - 13:15



<h2>Instruktioner</h2>

<ol>

<li>
Den här hemtentan ersätter den planerade salstentan.

<li>
Uppgifterna ska lösas enskilt, dvs inga grupper av två eller flera studenter.

<li>
<b>Du får använda dator, böcker och vilka andra hjälpmedel som helst,</b>
men du får inte samarbeta eller fråga någon (utom mig).
Exempelvis är det tillåtet att söka och läsa på webbplatser som Stack Overflow, men inte att ställa egna frågor.
Du kan alltså provköra kommandon och program, om du vill.

<li>
<b>Diskutera inte uppgifterna eller dela med dig av svar förrän tidigast dagen efter tentan.</b>

<li>
Lös de angivna uppgifterna och samla svaren på lämpligt sätt,
till exempel i en PDF.
Skicka sen in lösningarna till mig i
<a href="http://lms.oru.se/">Blackboard</a>.
Välj <b>Kursmaterial</b> i menyn till vänster på kursens Blackboard-sida,
gå in i mappen <b>Hemtentamen</b>,
och välj den rätta tentan.
Där kan man sedan välja att skicka in sin lösning.
Då blir bedömningen anonym.
Glöm inte att klicka på knappen <b>Skicka</b> längst ner till höger.

<li>
Om det skulle bli problem med Blackboard,
kan man i nödfall skicka in svaren
antingen som ett kursmeddelande i Blackboard
eller via vanlig e-post
(<a href="mailto:thomas.padron-mccarthy@oru.se?subject=Databasteknik-hemtenta 2021-06-01">thomas.padron-mccarthy@oru.se</a>),
senast vid tentatidens slut.
Då blir bedömningen inte anonym.

<li>
I Blackboard ser du att du skickat in din lösning.
Om du i stället skickade in med e-post,
och inte senast en timme efter tentatidens slut fått
ett svar från mig med en bekräftelse
på att du skickat in svaren,
bör du kontakta mig, enklast genom att ringa eller SMS:a mig
(ifall det är e-posten som inte fungerar).
Tänk på att en del mailtjänster
(särskilt Microsoft-tjänster som Hotmail.com, Outlook.com och Live.com)
ibland kastar bort brev med bilagor, utan att meddela det.

<li>
Skriv gärna svaren i ett ordbehandlingsprogram.
Rita gärna eventuella diagram i ett ritprogram.
Det är inte förbjudet att skriva och rita för hand,
men då måste text och bilder scannas in eller fotograferas.
Det finns scanner-appar till Android och iPhone,
till exempel Adobe Scan,
som ger bättre resultat än att bara ta vanliga kort med kameran.

<li>
Tentatiden är utökad med en extra timme
för att täcka in problem med e-post, inscanning eller fotografering av diagram, och liknande.

<li>
Om du behöver fråga något, så kontakta gärna mig.
Ring eller skicka SMS,
för jag kanske inte kommer att sitta vid datorn hela tiden.

<li>
Oklara och tvetydiga formuleringar kommer att misstolkas.
Lösningar som inte går att läsa eller förstå kan naturligtvis inte ge några poäng. 

<li>
Antaganden utöver de som står i uppgifterna måste anges. Gjorda antaganden får inte förändra den givna uppgiften.

<li>
Skriv gärna förklaringar om hur du tänkt. Även ett svar som är fel kan ge poäng, om det finns med en förklaring som visar att huvudtankarna var rätt. 

<li>
Maximal poäng är 30.
För godkänt betyg krävs minst 15 poäng.

<li>
Resultat meddelas senast 15 arbetsdagar efter tentamensdatum.
Eftersom svaren skickas in elektroniskt scannas tentorna inte för retur.

</ol>



<h2>Information från institutionen angående fusk</h2>

<table border="1" cellspacing="0" cellpadding="3" width="100%"><tr><td bgcolor="yellow">

<b>Instruktioner inför digital hemtentamen/ examination</b>

<p>

<b>Jag vill undvika fusk - hur gör jag? / All form av fusk anmäls</b>
<br>
<b>Du ska följa instruktionerna för uppgiften.</b>
Om du är osäker, fråga ansvarig lärare om något i instruktionerna är oklart.
<br>
<b>Du får inte samarbeta.</b>
Det här är en individuell examinationsuppgift. Du ska inte prata med någon, ställa frågor till eller ta hjälp av andra studenter eller kurskamrater. Att hjälpa andra under en individuell examination är också fusk.

<p>

<b>Lägg undan mobilen.</b> Stäng av sociala medier.

<p>

<b>Du får inte använda hjälpmedel.</b>
Det vill säga att du får inte använda dig av något annat än det som står angivet i instruktionerna.
<br>
<b>Du får inte använda andra formuleringar än dina egna.</b>
Dina svar ska vara <b>självständigt formulerade</b> och <b>redovisa dina kunskaper.</b>
Det betyder att inga citat eller referat ska förekomma i dina svar om det inte står i instruktionerna att du får använda citat eller referat.
<br>
<b>Dina svar kontrolleras via Urkund.</b>
<br>
<b>All misstanke om fusk anmäls</b> till universitetets rektor och kan leda till en prövning i universitets disciplinnämnd.

<p>

<b>Konsekvenser av fusk</b>

<p>

Om du fuskar kan detta leda till en avstängning som kan få följder både för dina studier och privat:

<ul>
<li>Uteblivet studiemedel som t.ex. som kan påverka din möjlighet att behålla din bostad.

<li>Ingen åtkomst till digitala plattformar.

<li>Du kan behöva meddela dina kursare om att du är fälld för fusk, om du t.ex. ingår i ett grupparbete på en pågående kurs men blir avstängd.

<li>Tillfällen för examination går förlorade vilket kan innebära att du inte kommer vidare i dina studier nästa läsperiod/termin och din studiegång blir därmed påverkad.

<li>Beslutet är en offentlig handling som begärs regelbundet ut av en nyhetsbyrå. Och kan även begäras ut av framtida arbetsgivare eller andra.

<li>Om du fuskar dig igenom din utbildning har du inte den kunskap som arbetsmarknaden förväntar av dig.
</ul>

<b>OBS: Tänk efter en gång till innan du påbörjar och genomför din tentamen!</b>

</td></tr></table>



<P CLASS="breakhere">



<a name="uppgift-1"></a>
<h2>Uppgift 1 (5 p)</h2>

a) Varför kan ett systemanrop innebära ett avbrott ("interrupt")?

<p>

b) Långt efter att systemanropet gjorts kan det förekomma fler interrupt,
som en del av arbetet som utförs av systemanropet. Beskriv hur det kan gå till!



<a name="uppgift-2"></a>
<h2>Uppgift 2 (5 p)</h2>

Task-structen, eller PCB som den också kallas,
är en av de viktigaste datastrukturerna som finns i operativsystemkärnan.

<p>

a) Vad används den till?

<p>

b) Vad innehåller den?

<p>

c) Task-structen förekommer i flera olika köer i operativsystemkärnan.
Vad är det för köer, och vad används de till?  



<a name="uppgift-3"></a>
<h2>Uppgift 3 (6 p)</h2>

Vi konstruerar en processor där fysiska adresser är 37 bitar,
medan virtuella adresser är 33 bitar,
varav 22 bitar är sidnummer ("page number" på engelska) och 11 bitar är offset.

<p>

a) Hur stor är en minnessida ("page")? Visa hur du räknat.

<p>

b) Fysiska ramar ("frames") kommer att vara lika stora som minnessidorna. Förklara varför!

<p>

c)
På den här processorn har fysiska adresser fler bitar än virtuella adresser.
Är det något konstigt med det?
Vad innebär det?

<p>

d)
Hur mycket plats (i byte) tar page-tabellen för en process?
Gör rimliga antaganden, redovisa dem, och förklara hur du räknat!

<p>

e) Den virtuella minnessidan nummer <b>2</b> (binärt: <b>10</b>)
lagras i fysisk frame nummer <b>0</b> (binärt: <b>0</b>).
På vilken fysisk minnesplats finns den virtuella adressen <b>4097</b>
(binärt <b>1000000000001</b>)?



<P CLASS="breakhere">



<a name="uppgift-4"></a>
<h2>Uppgift 4 (7 p)</h2>

Här är programmet <b>threads-1</b>, som startar två trådar,
och där varje tråd ökar variabeln <b>data</b> med ett en miljon gånger.
Slutresultatet borde förstås bli att variabeln innehåller värdet två miljoner.

<p>

Programmet <a href="threads-1.c">threads-1.c</a>:

<table border="1" cellspacing="0" cellpadding="3" width="90%"><tr><td bgcolor="#ccffcc">
<pre>
// threads-1.c

#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;

volatile long long data = 0;

void *thread_body(void *arg) {
    for (int i = 0; i &lt; 1000*1000; ++i) {
        ++data;
    }
    return NULL;
}

int main(void) {
    pthread_t thread1, thread2;
    pthread_create(&amp;thread1, NULL, thread_body, NULL);
    pthread_create(&amp;thread2, NULL, thread_body, NULL);
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);
    printf("Result: data = %lld\n", data);
}
</pre>
</td></tr></table>

<p>

a) Vi kör programmet,
men variabelns värde blir inte alls två miljoner, utan 1028606.
Vad beror det på att det blir fel värde?

<p>

b) Vi flyttar om raderna i <b>main</b>-funktionen så den ser ut enligt nedan.
Vad blir variabelns värde nu, och vad beror det på?

<p>

Ur programmet <a href="threads-2.c">threads-2.c</a>:

<table border="1" cellspacing="0" cellpadding="3" width="90%"><tr><td bgcolor="#ccffcc">
<pre>
int main(void) {
    pthread_t thread1, thread2;
    pthread_create(&amp;thread1, NULL, thread_body, NULL);
    pthread_join(thread1, NULL);
    pthread_create(&amp;thread2, NULL, thread_body, NULL);
    pthread_join(thread2, NULL);
    printf("Result: data = %lld\n", data);
}
</pre>
</td></tr></table>

<p>

c) Kan man gissa något om hur körtiden för <b>threads-2</b> kommer att bli, jämfört med <b>threads-1</b>?
Vad beror det på?
(Vi talar om den så kallade "väggklocketiden", som är den verkliga tid som det tog att köra programmen,
och som man till exempel skulle kunna mäta genom att titta på en väggklocka).

<p>

d) Vi har glömt hur man skrev för att använda pthread-paketets lås,
så vi försöker göra ett lås själva, så programmet ser ut enligt nedan.
Fungerar låset? Kommer variabelns värde att bli två miljoner nu? Förklara!

<p>

Programmet <a href="threads-3.c">threads-3.c</a>:

<table border="1" cellspacing="0" cellpadding="3" width="90%"><tr><td bgcolor="#ccffcc">
<pre>
// threads-3.c

#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;

volatile long long data = 0;
volatile int locked = 0;

void *thread_body(void *arg) {
    for (int i = 0; i &lt; 1000*1000; ++i) {
        // First, wait for the lock in a loop:
        while (locked) { }
        // Lock is free, lock it:
        locked = 1;
        ++data;
        // Release the lock:
        locked = 0;
    }
    return NULL;
}

int main(void) {
    pthread_t thread1, thread2;
    pthread_create(&amp;thread1, NULL, thread_body, NULL);
    pthread_create(&amp;thread2, NULL, thread_body, NULL);
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);
    printf("Result: data = %lld\n", data);
}
</pre>
</td></tr></table>

<p>

e) Visa hur man gör låsningen på rätt sätt, med pthread-paketets lås.



<P CLASS="breakhere">



<a name="uppgift-5"></a>
<h2>Uppgift 5 (7 p)</h2>

Här är fem program som alla skriver en tio megabyte
(10485760 byte) stor fil som heter <b>garbage</b>,
och som bara innehåller bokstaven 'x'.

<ul>
<li>Programmet <b>create-garbage-1</b> skriver ett tecken 10485760 gånger.
<li>Programmet <b>create-garbage-2</b> skriver en kilobyte (1024 byte) 10240 gånger.
<li>Programmet <b>create-garbage-3</b> skriver 10 kilobyte (10240 byte) 1024 gånger.
<li>Programmet <b>create-garbage-4</b> skriver hela filen (10485760 byte) på en gång.
<li>Programmet <b>create-garbage-5</b> startar tio trådar,
    som var och en skriver en tiondel av filen (en megabyte, 1048576 byte) på en gång.
</ul>

Programmen:

<p>

<a href="create-garbage-1.c">create-garbage-1.c</a>

<table border="1" cellspacing="0" cellpadding="3" width="90%"><tr><td bgcolor="#ccffcc">
<pre>
// create-garbage-1.c

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

#define KILO 1024
#define MEGA KILO*KILO

int main(void) {
    char buffer[1];
    buffer[0] = 'x';
    int outfd = open("garbage", O_CREAT | O_WRONLY | O_TRUNC, S_IRWXU);
    for (int i = 0; i &lt; 10*MEGA; ++i)
        write(outfd, buffer, sizeof buffer);
    close(outfd);
}
</pre>
</td></tr></table>

<p>

<a href="create-garbage-2.c">create-garbage-2.c</a>

<table border="1" cellspacing="0" cellpadding="3" width="90%"><tr><td bgcolor="#ccffcc">
<pre>
// create-garbage-2.c

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

#define KILO 1024
#define MEGA KILO*KILO

char buffer[KILO];

int main(void) {
    for (int i = 0; i &lt; sizeof buffer; ++i)
        buffer[i] = 'x';
    int outfd = open("garbage", O_CREAT | O_WRONLY | O_TRUNC, S_IRWXU);
    for (int i = 0; i &lt; 10*KILO; ++i)
        write(outfd, buffer, sizeof buffer);
    close(outfd);
}
</pre>
</td></tr></table>

<p>

<a href="create-garbage-3.c">create-garbage-3.c</a>

<table border="1" cellspacing="0" cellpadding="3" width="90%"><tr><td bgcolor="#ccffcc">
<pre>
// create-garbage-3.c

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

#define KILO 1024
#define MEGA KILO*KILO

char buffer[10*KILO];

int main(void) {
    for (int i = 0; i &lt; sizeof buffer; ++i)
        buffer[i] = 'x';
    int outfd = open("garbage", O_CREAT | O_WRONLY | O_TRUNC, S_IRWXU);
    for (int i = 0; i &lt; KILO; ++i)
        write(outfd, buffer, sizeof buffer);
    close(outfd);
}
</pre>
</td></tr></table>

<p>

<a href="create-garbage-4.c">create-garbage-4.c</a>

<table border="1" cellspacing="0" cellpadding="3" width="90%"><tr><td bgcolor="#ccffcc">
<pre>
// create-garbage-4.c

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

#define KILO 1024
#define MEGA KILO*KILO

char buffer[10*MEGA];

int main(void) {
    for (int i = 0; i &lt; sizeof buffer; ++i)
        buffer[i] = 'x';
    int outfd = open("garbage", O_CREAT | O_WRONLY | O_TRUNC, S_IRWXU);
    write(outfd, buffer, sizeof buffer);
    close(outfd);
}
</pre>
</td></tr></table>

<p>

<a href="create-garbage-5.c">create-garbage-5.c</a>

<table border="1" cellspacing="0" cellpadding="3" width="90%"><tr><td bgcolor="#ccffcc">
<pre>
// create-garbage-5.c

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;pthread.h&gt;

#define KILO 1024
#define MEGA KILO*KILO

char buffer[MEGA];

void *thread_body(void *arg) {
    int thread_number = (int)arg;
    printf("starting thread %d...\n", thread_number);
    int outfd = open("garbage", O_WRONLY);
    // lseek moves to the place in the file where this thread will write
    lseek(outfd, thread_number * MEGA, SEEK_SET);
    write(outfd, buffer, sizeof buffer);
    close(outfd);
    printf("done thread %d\n", thread_number);
    return NULL;
}

int main(void) {
    for (int i = 0; i &lt; sizeof buffer; ++i)
        buffer[i] = 'x';
    // To ensure the file exists and is empty before the threads start
    int outfd = open("garbage", O_CREAT | O_WRONLY | O_TRUNC, S_IRWXU);
    close(outfd);
    pthread_t threads[10];
    for (int thread = 0; thread &lt; 10; ++thread)
        pthread_create(&amp;threads[thread], NULL, thread_body, (void*)thread);
    for (int thread = 0; thread &lt; 10; ++thread)
        pthread_join(threads[thread], NULL);
}
</pre>
</td></tr></table>

<p>

När vi provkör programmen mäter vi upp dessa körtider:

<p>

<table border="1" cellspacing="0" cellpadding="3">
<tr><th>Program</th> <th>Körtid</th></tr>
<tr><td>create-garbage-1</td> <td>6.253 s</td></tr>
<tr><td>create-garbage-2</td> <td>0.019 s</td></tr>
<tr><td>create-garbage-3</td> <td>0.013 s</td></tr>
<tr><td>create-garbage-4</td> <td>0.018 s</td></tr>
<tr><td>create-garbage-5</td> <td>0.005 s</td></tr>
</table>

<p>

a) Varför är <b>create-garbage-1</b> så väldigt långsamt? Förklara!

<p>

b) Kan man förklara körtiderna för programmen
<b>create-garbage-2</b>,
<b>create-garbage-3</b> och
<b>create-garbage-4</b>?

<p>

c) Kan man säga något om hur många processorkärnor som datorn vi provkörde på har?
Vad, och varför?

<p>

d) Ett program kan vara flertrådat, men man talar också om flertrådade operativsystemkärnor.
Kan man säga något om ifall operativsystemkärnan på datorn som vi provkörde på är flertrådad?
Vad, och varför?

<p>

<hr>

<font size=-1>
<a href="http://www.aass.oru.se/~tpy/">Thomas Padron-McCarthy</a>
(<a href="mailto:thomas.padron-mccarthy@oru.se?subject=Operativsystem-hemtenta 2021-06-01">thomas.padron-mccarthy@oru.se</a>),
31 maj 2021
</font>

</body>
</html>
